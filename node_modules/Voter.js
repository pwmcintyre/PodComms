

var PodComms = require('PodComms');
var _ = require('underscore');

//Voter class
var running = false;

var name,
	list,
	users,
	winCallback,

	entries,
	userData,

	timeLimit,
	timeLimitMin = 15,
	timeLimitPerChoice = 5,
	timeWarning,
	timeWarningRatio = 2/3,
	timers = [],

	selectionRegex = /(\d+)/g,

	voteTypes = [
		{
			name: 'upvotes',
			command: 'up',
			maxFunc: function(){ return Math.ceil(Math.min(5,list.length/2)) },
			effect: function (entry) {
				entry.score++;
			}
		}, {
			name: 'downvotes',
			command: 'down',
			maxFunc: function(){ return Math.ceil(Math.min(5,list.length/2)) },
			effect: function (entry) {
				entry.score--;
			}
		}, {
			name: 'veto',
			command: 'veto',
			maxFunc: function(){ return Math.max( 0, Math.floor( (list.length - users.length - 1) / 10) )},
			effect: function (entry) {
				entry.veto = true;
				PodComms.Message.public(entry.name+' has vetoed!!');
			}
		}
	];

function start (iname, ilist, iusers, iwinCallback) {

	name = iname;
	list = ilist;
	users = iusers;
	winCallback = iwinCallback;

	_.each(voteTypes, function(v){
		if(v.maxFunc) v.max = v.maxFunc();
	});

	// There can only be one
	if (running != false) {
		PodComms.Message.public("Can't start another vote yet");
		return;
	}
	running = this;

	PodComms.Message.public('Let the '+ name +' voting begin!');

	// Load Users
	userData = [];
	for (var i = 0; i < users.length; i++) {
		var user = {
			name: users[i].name,
			userObj: users[i],
			votes: [voteTypes.length]
		}
		userData[i] = user;
		userData[user.name] = user;
	}

	// Load Entries
	entries = [];
	var choices = [];
	for (var i = 0; i < list.length; i++) {
		var entry = {
			name: list[i].name || list[i],
			score: 0,
			veto: false,
			item: list[i]
		}
		entries[i] = entry;
		entries[entry.name] = entry;

		choices.push( entry.name );
	}

	// Set up voting type callbacks
	_.each(voteTypes, function(type) {
		if (type.max > 0) {
			PodComms.Command.register('vote '+type.command, {
				example: '/vote '+type.command+' 1 2 5',
				extra: type,
				callback: function(user, msg, match, extra) {
					callback (user, msg, match, extra);
				}
			});
		}
	});

	// Start timers to calculate timeLimit
	startTimers();

	sendScores();
	sendCommands();
	PodComms.Message.public('You each have <b>' + timeLimit + ' seconds</b><span class="startvote"/>!');
	PodComms.Command.register('vote end', finish);
	PodComms.Command.register('vote abort', abort);
	PodComms.Command.register('vote list', function(user, msg, match) {
		sendScores(user);
	});
}

function startTimers () {
	timeLimit = Math.max(timeLimitMin, entries.length * timeLimitPerChoice );
	timers.push(setTimeout(function(){
		finish();
	}, timeLimit*1000));

	timeWarning = timeLimit * timeWarningRatio;
	timers.push(setTimeout(function(){
		sendScores(false, true);
		PodComms.Message.public('Only <b>'+ Math.ceil(timeLimit-timeWarning) +' seconds</b> remain to vote!');
	}, timeWarning*1000));
}

function sendCommands (user, showScores) {
	var text = [];
	_.each(voteTypes, function(type) {
		if (type.max > 0) {
			this.push( type.max + ' ' + type.name + ' eg. <code>/vote ' + type.command + ' 2 1 3</code><span class="hide">' + type.command + '</span>' );
		}
	}, text);

	PodComms.Message.public('Here are the commands:<br /><ul class="votecommands"><li>' + text.join('</li><li>') + '</li></ul>');
}

function sendScores (user, showScores) {
	var choices = [];

	if (showScores) {
		_.each(entries, function(entry){
			this.push( (entry.veto ? '<del>' : '') + 
				'<b>(' + entry.score + ')</b> ' + 
				entry.name + (entry.veto ? '</del>' : '') );
		}, choices)
	} else {
		choices=  _.pluck(entries, 'name');
	}

	var text = (showScores ? 'Current scores' : 'Chocies') + ':<br /><ol class="votelist"><li onclick="">' + choices.join('</li><li>') + '</li></ol>';

	if (user) {
		PodComms.Message.private(text, user);
	} else {
		PodComms.Message.public(text);
	}
}

function sortEntries () {
	return entries.sort(function(a1, b1) {
		var a = a1.veto ? -9999 : a1.score;
		var b = b1.veto ? -9999 : b1.score;

		return (a == b) ? 0 : a < b ? 1 : -1;
	});
}

function callback (inuser, msg, match, voteType) {
	var user = userData[inuser.name];
	if (!user) {
		PodComms.Message.private("Sorry, you're not registered to vote", user);
		return;
	}

	var votes = msg.match(selectionRegex);

	if (!user.votes[voteType.name]) user.votes[voteType.name] = [];

	// apply each vote from the message
	while (votes.length && user.votes[voteType.name].length < voteType.max) {
		var choice = parseInt(votes.pop())-1;
		var entry = entries[choice];

		if (entry) {
			// Make sure they haven't already votes for this choice
			var already = false;
			for (var v = 0; v < user.votes[voteType.name].length; v++) {
				if (choice == user.votes[voteType.name][v])
					already = true;
			}

			if (!already) {
				user.votes[voteType.name].push( choice );
				voteType.effect( entry );

				PodComms.Message.private(voteType.name + ' for ' + entry.name, inuser);
			}

		} else {
			PodComms.Message.private('Unknown entry: ' + (choice+1), inuser);
		}
	}
}

function finish () {

	PodComms.Message.public(name + ' voting Complete!<span class="endvote"/>');

	cleanup();

	var sorted = sortEntries();

	var highScorerers = [];
	var choices = [];
	for (var i = 0; i < sorted.length; i++) {
		choices.push( (sorted[i].veto ? '<del>' : '') + 
			'<b>(' + sorted[i].score + ')</b> ' + 
			sorted[i].name + (sorted[i].veto ? '</del>' : '') );

		if (!sorted[i].veto && sorted[i].score == sorted[0].score) {
			highScorerers.push(sorted[i].item);
		}
	}

	PodComms.Message.public('Final scores:<br /><ul><li>' + choices.join('</li><li>') + '</li></ul>');

	// In case of tie
	if (highScorerers.length > 1) {
		PodComms.Message.public('Wait what? A tie? <b>AGAIN!!!!!!!!!!!!</b>');
		start(name, highScorerers, users, winCallback);
	} else if (highScorerers.length == 0) {
		PodComms.Message.public('WTF? No results? <b>AGAIN!!!!!!!!!!!!</b>');
		start(name, list, users, winCallback);
	} else {
		winCallback(sorted[0].item, sorted);
	}
}

function abort() {
	PodComms.Message.public('Vote aborted<span class="endvote"/>');
	cleanup();
}

function cleanup() {
	// Clear timers
	while (timers.length) clearTimeout( timers.pop() );

	// Deregister commands
	PodComms.Command.deregister('vote end');
	PodComms.Command.deregister('vote list');
	PodComms.Command.deregister('vote abort');
	_.each(voteTypes, function(t){
		PodComms.Command.deregister('vote '+t.command);
	});

	running = false;
}

exports.start = start;