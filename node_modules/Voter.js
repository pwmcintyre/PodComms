

var PodComms = require('PodComms');
var _ = require('underscore.js');

Array.splat = function (obj) {
	return _.isArray(obj) ? obj : [obj];
}

//Voter class
var Voter = function (name, list, users, winCallback) {
	Voter.running = Voter.running || false;
	
	var my = {};
	var name = name;
	var list = list;
	var users = users;
	var winCallback = winCallback;

	var entries;
	var userData;

	var timeLimit = 10;
	var timePerEntry = 30;

	function timer () {
		setTimeout(function(){

		}, timeLimit);
	}

	var selectionRegex = /(\d+)/g;

	var voteTypes = [
		{
			name: 'upvotes',
			command: 'up',
			max: 5,
			effect: function (entry) {
				entry.score++;
			}
		},
		{
			name: 'downvotes',
			command: 'down',
			max: 5,
			effect: function (entry) {
				entry.score--;
			}
		},
		{
			name: 'veto',
			command: 'veto',
			max: 1,
			effect: function (entry) {
				entry.veto = true;
				PodComms.Messaging.public(entry.name+' has vetoed!!');
			}
		}
	];

	function init() {
		// There can only be one
		if (Voter.running != false) {
			PodComms.Messaging.public("Can't start another vote yet");
			return;
		}
		Voter.running = this;

		PodComms.Messaging.public('Let the '+ name +' voting begin!');

		// Load Users
		userData = []
		for (var i = 0; i < users.length; i++) {
			var user = {
				name: users[i].name,
				userObj: users[i],
				votes: [voteTypes.length]
			}
			userData[i] = user;callback
			userData[user.name] = user;
		}

		// Load Entries
		entries = []
		var choices = [];
		for (var i = 0; i < list.length; i++) {
			var entry = {
				name: list[i].name || list[i],
				score: 0,
				veto: false,
				item: list[i]
			}
			entries[i] = entry;
			entries[entry.name] = entry;

			choices.push( entry.name );
		}
		PodComms.Messaging.public('Here are the choices:<br /><ol><li>' + choices.join('</li><li>') + '</li></ol>');

		// Set up voting type callbacks
		var text = [];
		for (var i = 0; i < voteTypes.length; i++) {
			var type = voteTypes[i];
			PodComms.Command.register('vote '+voteTypes[i].command, {
				example: '/vote '+voteTypes[i].command+' 1 2 5',
				extra: type,
				callback: function(user, msg, match, extra) {
					callback (user, msg, match, extra);
				}
			});

			text.push( voteTypes[i].max + ' ' + voteTypes[i].name + ' eg. <code>/vote ' + voteTypes[i].command + ' 2 1 3</code>' )
		}
		PodComms.Messaging.public('Here are the commands:<br /><ul><li>' + text.join('</li><li>') + '</li></ul>');

		PodComms.Messaging.public('You each have <b>' + timeLimit + ' seconds</b>!');

		PodComms.Command.register('vote end', finish);
		PodComms.Command.register('vote list', function(user, msg, match) {
			broadcastChoices(user);
		});
		PodComms.Command.register('vote abort', abort);
	}

	function broadcastChoices(user) {
		var choices = [];
		for (var i = 0; i < list.length; i++) {
			var entry = {
				name: list[i].name || list[i],
				score: 0,
				veto: false,
				item: list[i]
			}

			choices.push( entry.name );
		}
		var text = 'Here are the choices:<br /><ol><li>' + choices.join('</li><li>') + '</li></ol>';

		if (user) {
			PodComms.Messaging.private(text, user);
		} else {
			PodComms.Messaging.public(text);
		}
	}

	function callback (inuser, msg, match, voteType) {
		var user = userData[inuser.name];
		if (!user) {
			PodComms.Messaging.private("Sorry, you're not registered to vote", user);
			return;
		}

		var votes = msg.match(selectionRegex);

		if (!user.votes[voteType.name]) user.votes[voteType.name] = [];

		// apply each vote from the message
		while (votes.length && user.votes[voteType.name].length < voteType.max) {
			var choice = parseInt(votes.pop())-1;
			var entry = entries[choice];

			if (entry) {
				// Make sure they haven't already votes for this choice
				var already = false;
				for (var v = 0; v < user.votes[voteType.name].length; v++) {
					if (choice == user.votes[voteType.name][v])
						already = true;
				}

				if (!already) {
					user.votes[voteType.name].push( choice );
					voteType.effect( entry );

					PodComms.Messaging.private(voteType.name + ' for ' + entry.name, inuser);
				}

			} else {
				PodComms.Messaging.private('Unknown entry: ' + (choice+1), inuser);
			}
		}
	}

	function finish () {

		PodComms.Messaging.public(name + ' voting Complete!');

		cleanup();

		var sorted = entries.sort(function(a1, b1) {
			var a = a1.veto ? -9999 : a1.score;
			var b = b1.veto ? -9999 : b1.score;

			return (a == b) ? 0 : a < b ? 1 : -1;
		});


		var highScorerers = [];
		var choices = [];
		for (var i = 0; i < sorted.length; i++) {
			choices.push( (sorted[i].veto ? '<del>' : '') + 
				'<b>(' + sorted[i].score + ')</b> ' + 
				sorted[i].name + (sorted[i].veto ? '</del>' : '') );

			if (!sorted[i].veto && sorted[i].score == sorted[0].score) {
				highScorerers.push(sorted[i].item);
			}
		}

		PodComms.Messaging.public('Final scores:<br /><ul><li>' + choices.join('</li><li>') + '</li></ul>');

		Voter.running = false;

		// In case of tie
		if (highScorerers.length > 1) {
			PodComms.Messaging.public('Wait what? A tie? <b>AGAIN!!!!!!!!!!!!</b>');
			new Voter('lunch', highScorerers, users, winCallback);
		} else {
			winCallback(sorted[0].item, sorted);
		}
	}

	function abort() {
		PodComms.Messaging.public('Vote aborted');
		cleanup();
	}

	function cleanup() {
		PodComms.Command.deregister('vote end');
		PodComms.Command.deregister('vote list');
		for (var i = 0; i < voteTypes.length; i++) {
			var type = voteTypes[i];
			PodComms.Command.deregister('vote '+voteTypes[i].command);
		}
	}

	init();

	return my;
}