


// app
var port = (process.argv[2]) ? process.argv[2] : 80 ;

var fs = require('fs'),
	url = require('url'),
	_ = require('underscore');

// setup servers
var express = require('express'),
	app = express(),
	http = require('http'),
	server = http.createServer(app),
	io = require('socket.io').listen(server),
	winston = require('winston');

var logger = new (winston.Logger)({
	transports: [
		new (winston.transports.Console)({colorize: 'true'}),
		new (winston.transports.File)({ filename: 'log.txt', json: false })
	]
});

winston.handleExceptions(new winston.transports.File({ filename: 'uncaughtExceptions.log', json: true }));

process.on('uncaughtException', function(err) {
	logger.error("Uncaught exception!", err);
	console.error("Uncaught exception!", err);
});

io.set('log level', 1);

server.listen(port);

// Set up routing
app.get('/assets/*', function(req, res) {
	logger.log(url.parse(req.url, true).pathname);
	var file = './client/' + url.parse(req.url, true).pathname;

	fs.exists(file, function(exists) {
		if (exists) {
			res.sendfile(file);
		} else {
			res.statusCode = 404;
			res.end('File not found.')
		}
	});
}).get('/*', function(req, res) {
	res.sendfile('./client/index.html');
});
logger.debug("Routing: ", app.routes);

// Command namespace
var PodComms = {};
PodComms.Command = (function (parent) {
	var commands = [];
	var synonyms = [];
	function register (name, parms) {

		// If parms = function, assume it's the callback
		if (_.isFunction(parms))
			parms = {callback:parms};

		// List of synonyms + original name
		var syn = parms.synonyms || [];
		syn.unshift(name);

		// Must be unique
		var nonUnique = _.intersection(synonyms, syn);
		if (nonUnique.length) {
			logger.warn('Can\'t add command, these synonyms already exists: '+nonUnique.join(', '));
			return;
		}

		var regex = new RegExp('^\/'+ syn.join('|') +'\\b ?(.*)');

		var command = {
			command: name,
			synonyms: syn,
			regex: regex, 
			description: parms.description || '',
			example: parms.example || '',
			callback: parms.callback || null,
			extra: parms.extra || '',
		};

		commands.push(command);

		logger.info('Command registered: '+name+ ' regex: '+regex);
	}
	function deregister (command) {
		for (var i = 0; i < commands.length; i++) {
			if (command == commands[i].command) {
				commands.splice(i, 1);
				logger.info('Command '+command+' removed');
				break;
			}
		}
	}
	function find (name) {
		var even = _.find(commands, function(command){ return command.name == this; }, name);
	}
	function applyCommands (text, user) {
		for (var i = 0; i < commands.length; i++) {
			var command = commands[i];

			var match = text.match(command.regex);

			if (match) {
				text = command.callback(user, text, match, command.extra) || '';
				break;
			}
		}
		return text;
	}
	function getAll () {
		return commands;
	}

	// Help command
	register('help', {
		description: 'List all commands', 
		synonyms: ['halp'],
		example: '/help', 
		callback: function(user, msg, match){
			var commands = PodComms.Command.getAll();
			var list = [];
			for (var i = 0; i < commands.length; i++){
				var c = commands[i];

				var cmds = [];
				for (var s = 0; s < c.synonyms.length; s++){
					cmds.push(c.synonyms[s]);
				}

				var text = '<code>/'+cmds.join('</code>, <code>/')+'</code>';
				if (c.description) text += ': '+c.description
				if (c.example) text += ' <code>'+c.example+'</code>';

				list.push(text);
			}

			var choices = '<ul><li>' + list.join('</li><li>') + '</li></ul>';
			PodComms.Message.private('Command list: <br />'+choices, user);
		}
	});

	return {
		register: register,
		deregister: deregister,
		find: find,
		applyCommands: applyCommands,
		getAll: getAll
	};
} (PodComms.Command || {}));



// User namespace
PodComms.User = (function (parent) {
	var users = [];
	var userSockets = [];

	var broadcastUserList = function () {
		PodComms.Message.send('updateUserList', users);
	}
	function getUsers () {
		return users;
	}
	function getSockets () {
		return userSockets;
	}
	function find (name) {
		return users[name];
	}
	function add (inname, socket, oldUser, lastMessage) {
		var name = inname.replace(/(<([^>]+)>)/ig,'').replace(/ /g, '').substring(0,10);

		// must have at least 1 non-digit
		if (name.match(/^\d+$/)) return;

		// no server
		if (name == 'server') return;

		if ( name.length > 0 && name != null && !PodComms.User.find(name) ) {

			socket.username = name;

			PodComms.Message.public(name + (oldUser ? ' has reconnected' : ' has joined.') );

			var user = {
				name: name,
				colour: (oldUser && oldUser.colour) ? oldUser.colour : '#'+(Math.random()*0xFFFFFF<<0).toString(16),
				socketID: socket.id,
			}
			users.push(user);
			userSockets.push(socket);

			users[name] = user;
			userSockets[socket.id] = socket;

			broadcastUserList();
			socket.emit('updateSignedIn', user);

			PodComms.Message.Logging.sendLogToUser(user, lastMessage);

			logger.info((oldUser ? 'User reconnected: ' : 'User joined: ') + JSON.stringify(user) );
			return user;
		}
		return false;
	}
	function remove (name) {
		for (var i = 0; i < users.length; i++) {
			if (users[i].name == name) {
				userSockets[users[i].socketID] = null;
				users[users[i].name] = null;

				userSockets.splice(i,1);
				users.splice(i,1);

				PodComms.Message.public(name + ' has left.');
				broadcastUserList();

				logger.info('User left: '+name);
			}
		}
	}

	return {
		getUsers: getUsers,
		getSockets: getSockets,
		find: find,
		add: add,
		remove: remove
	};
} (PodComms.User || {}));




// Messaging namespace
PodComms.Message = (function (parent) {

	// server messaging
	function send (event, obj, user) {
		if (user && user.socketID) {
			var socket = PodComms.User.getSockets()[user.socketID];
			if (socket) {
				socket.emit(event, obj);
			}
			return;
		}

		var userSockets = PodComms.User.getSockets();

		for (var i = 0; i < userSockets.length; i++) {
			userSockets[i].emit(event, obj);
		}
	}

	function private (msg, to, from) {
		sendMessage(msg, {from:from, to:to});
	}

	function public (msg, from) {
		sendMessage(msg, {from:from});
	}

	function sendMessage (msg, parms) {
		parms = parms || {};

		// If not a server message
		if (parms.from)
			msg = parseMessage( msg );

		var obj = {
			'username': (parms.from && parms.from.name) ? parms.from.name : 'server',
			'colour': (parms.from && parms.from.colour) ? parms.from.colour : '#e20000',
			'message': msg,
			'datestamp': Date.now()
		};

		if (parms.to) {

			//private
			var userSockets = PodComms.User.getSockets();
			userSockets[parms.to.socketID].emit('updateChat', obj);

		} else {

			//public
			send('updateChat', obj);
			PodComms.Message.Logging.logMessage (obj);

		}
	}

	function parseMessage (msg) {
		var linkRegex = /(\b(https?|ftp|file):\/\/[\-A-Z0-9+&@#\/%?=~_|!:,.;]*[\-A-Z0-9+&@#\/%=~_|])/ig;
		var links = msg.match(linkRegex);
		if (links) {
			for (var i=0; i<links.length; i++) {
				var l = links[i];

				if ( l.match(/(.gif|.jpg|.png)$/) ) {
					var embed = '<img src="' + l + '"/>';
					var rxstr = l.replace(/\//g, '\\/');
					var rx = RegExp(rxstr, 'i');
					msg = msg.replace(rx, embed);
				} else {
					var embed = '<a href="' + l + '" target="_blank">' + l + '</a>';
					var rxstr = l.replace(/\//g, '\\/').replace(/\?/g, '\\?');
					var rx = RegExp(rxstr, 'i');
					msg = msg.replace(rx, embed);
				}
			}
		}

		var imgRegex = /(data:image\/.*?):data/ig;
		msg = msg.replace(imgRegex, "<img src='$1'>");

		var nlRegex = /(\r\n|\n|\r)/gm
		msg = msg.replace(nlRegex, "<br />");

		return msg;
	}

	return {
		send: send,
		sendMessage: sendMessage,
		private: private,
		public: public
	}

} (PodComms.Message || {}));

// Logging namespace
PodComms.Message.Logging = (function (pub) {

	var chatlog = [];
	var chatlogSize = 20;
	var chatlogFile = 'chatlog.txt';

	function logMessage (obj) {
		
		chatlog.push( obj );
		chatlog = chatlog.splice(-chatlogSize);

		var text = (fs.existsSync(chatlogFile) ? ',' : '[') + JSON.stringify(obj);

		fs.appendFile(chatlogFile, text, function (err) {
			if (err) logger.error('Write log failure'+err);
		});
	}

	function loadFromFile () {
		if (fs.existsSync(chatlogFile)){

			try {
				// Read file
				var data = fs.readFileSync(chatlogFile);

				// Parse
				var array = JSON.parse( data + ']' );

				chatlog = array.splice(-chatlogSize);

				logger.info( 'Chat history read success' );

			} catch (e) {
				logger.error( 'Chat history read fail'+e );
			}
		} else {
			logger.info( 'No chat history found' );
		}
	}

	function sendLogToUser (user, lastMessage) {
		var array;

		if (false && lastMessage) {
			array = new Array();
			for (var i = chatlog.length-1; i >= 0; i--) {
				if (!_.isEqual(lastMessage, chatlog[i])) {
					array.push(chatlog[i]);
				} else {
					break;
				}
			}
		} else {
			array = chatlog;
		}

		PodComms.Message.send('updateChatHistory', array, user);
	}

	loadFromFile ();

	return {
		logMessage: logMessage,
		loadFromFile: loadFromFile,
		sendLogToUser: sendLogToUser,
		getChatLog: function () { return chatlog; }
	}
} (PodComms.Message.Logging || {}));

// Socket events
io.of('/chat').on('connection', function(socket) {

	// disconnect
	socket.on('disconnect', function() {
		if (socket.username) {
			PodComms.User.remove (socket.username);
		}
	});

	process.on('exit', function() {
		PodComms.Message.public('SERVER IS SHUTING DOWN!!11');
		PodComms.Message.public('If we\'re lucky, it\'ll restart itself');
		logger.warn('About to exit.');
	});

	// events
	socket.on('sendSignIn', function(d) {
		var user = PodComms.User.add(d, socket);
	});

	socket.on('testConnection', function(d) {
		if ( d && d.user && d.user.name && !PodComms.User.find(d.user.name) ) {
			PodComms.User.add(d.user.name, socket, d.user, d.lastMessage);
		}
	});

	socket.on('sendChat', function(d) {
		var user = PodComms.User.find(socket.username);

		if (!user) return;

		//strip html
		var msg = d.replace(/(<([^>]+)>)/ig,"");

		// Check commands
		msg = PodComms.Command.applyCommands(msg, user);

		// send chat
		if (msg && msg.length > 0) {
			PodComms.Message.public(msg, user);
		}
	});
});

exports.Command = PodComms.Command;
exports.User = PodComms.User;
exports.Message = PodComms.Message;
exports.Logger = logger;

require('./plugins');