


String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

// app
var port = (function() {
	if (process.argv[2]) return process.argv[2];
	else return 80;
})(port);

var fs = require('fs'),
	url = require('url'),
	_ = require('underscore');

// setup servers
var express = require('express'),
    app = express()
  , http = require('http')
  , server = http.createServer(app);

io = require('socket.io').listen(server);
io.set('log level', 1);

server.listen(port);

// img dir
app.get('/assets/*', function(req, res) {
	console.log(url.parse(req.url, true).pathname);
	var file = './client/' + url.parse(req.url, true).pathname;

	fs.exists(file, function(exists) {
		if (exists) {
			res.sendfile(file);
		} else {
			res.statusCode = 404;
			res.end('File not found.')
		}
	});
}).get('/*', function(req, res) {
	res.sendfile('./client/index.html');
});

// Command namespace
var PodComms = {};
PodComms.Command = (function (parent) {
	var commands = [];
	var synonyms = [];
	function register (name, parms) {

		// If parms = function, assume it's the callback
		if (_.isFunction(parms))
			parms = {callback:parms};

		// List of synonyms + original name
		var syn = parms.synonyms || [];
		syn.unshift(name);

		// Must be unique
		var nonUnique = _.intersection(synonyms, syn);
		if (nonUnique.length) {
			console.log('Can\'t add command, these synonyms already exists: '+nonUnique.join(', '));
			return;
		}

		var regex = new RegExp('^\/'+ syn.join('|') +'\\b ?(.*)');

		var command = {
			command: name,
			synonyms: syn,
			regex: regex, 
			description: parms.description || '',
			example: parms.example || '',
			callback: parms.callback || null,
			extra: parms.extra || '',
		};

		commands.push(command);

		console.log('Command registered: '+name+ ' regex: '+regex)
	}
	function deregister (command) {
		for (var i = 0; i < commands.length; i++) {
			if (command == commands[i].command) {
				commands.splice(i);
				console.log('Command '+command+' removed');
				break;
			}
		}
	}
	function find (name) {
		var even = _.find(commands, function(command){ return command.name == this; }, name);
	}
	function applyCommands (text, user) {
		for (var i = 0; i < commands.length; i++) {
			var command = commands[i];

			var match = text.match(command.regex);

			if (match) {
				text = commands[i].callback(user, text, match, commands[i].extra) || '';
			}
		}
		return text;
	}
	function getAll () {
		return commands;
	}

	// Help command
	register('help', {
		description: 'List all commands', 
		synonyms: ['halp'],
		example: '/help', 
		callback: function(user, msg, match){
			var commands = PodComms.Command.getAll();
			var list = [];
			for (var i = 0; i < commands.length; i++){
				var c = commands[i];

				var cmds = [];
				for (var s = 0; s < c.synonyms.length; s++){
					cmds.push(c.synonyms[s]);
				}

				var text = '<code>/'+cmds.join('</code>, <code>/')+'</code>';
				if (c.description) text += ': '+c.description
				if (c.example) text += ' <code>'+c.example+'</code>';

				list.push(text);
			}

			var choices = '<ul><li>' + list.join('</li><li>') + '</li></ul>';
			PodComms.Messaging.private('Command list: <br />'+choices, user);
		}
	});

	return {
		register: register,
		deregister: deregister,
		find: find,
		applyCommands: applyCommands,
		getAll: getAll
	};
} (PodComms.Command || {}));



// User namespace
PodComms.User = (function (parent) {
	var users = [];
	var userSockets = [];

	var broadcastUserList = function () {
		PodComms.Messaging.send('updateUserList', users);
	}

	return {
		getUsers : function () {
			return users;
		},
		getSockets : function () {
			return userSockets;
		},

		find : function (name) {
			return users[name];
		},
		add : function (inname, socket, oldUser) {
			var name = inname.replace(/(<([^>]+)>)/ig,'').replace(/ /g, '').substring(0,10);

			// must have at least 1 non-digit
			if (name.match(/^\d+$/)) return;

			if ( name.length > 0 && name != null && !PodComms.User.find(name) ) {

				socket.username = name;

				PodComms.Messaging.public(name + (oldUser ? ' has reconnected' : ' has joined.') );

				var user = {
					name: name,
					colour: (oldUser && oldUser.colour) ? oldUser.colour : '#'+(Math.random()*0xFFFFFF<<0).toString(16),
					socketID: socket.id,
				}
				users.push(user);
				userSockets.push(socket);

				users[name] = user;
				userSockets[socket.id] = socket;

				broadcastUserList();
				socket.emit('updateSignedIn', user);
				socket.emit('updateChatHistory', PodComms.Logging.getChatLog());

				console.log((oldUser ? 'User reconnected: ' : 'User joined: ') + JSON.stringify(user) );
				return user;
			}
			return false;
		},
		remove : function (name) {
			for (var i = 0; i < users.length; i++) {
				if (users[i].name == name) {
					userSockets[users[i].socketID] = null;
					users[users[i].name] = null;

					userSockets.splice(i,1);
					users.splice(i,1);

					PodComms.Messaging.public(name + ' has left.');
					broadcastUserList();

					console.log('User left: '+name);
				}
			}
		}
	};
} (PodComms.User || {}));

// Logging namespace
PodComms.Logging = (function (pub) {

	var chatlog = [];
	var chatlogSize = 20;
	var chatlogFile = 'chatlog.txt';

	function logMessage (obj) {
		
		chatlog.push( obj );
		chatlog = chatlog.splice(-chatlogSize);

		var text = (fs.existsSync(chatlogFile) ? ',' : '[') + JSON.stringify(obj);

		fs.appendFile(chatlogFile, text, function (err) {
			if (err) console.log('Write log failure'+err);
		});
	}

	function loadFromFile () {
		if (fs.existsSync(chatlogFile)){

			try {
				// Read file
				var data = fs.readFileSync(chatlogFile);

				// Parse
				var array = JSON.parse( data + ']' );

				chatlog = array.splice(-chatlogSize);

				console.log( 'Chat history read success' );

			} catch (e) {
				console.log( 'Chat history read fail'+e );
			}
		} else {
			console.log( 'No chat history found' );
		}
	}

	loadFromFile ();

	return {
		logMessage: logMessage,
		loadFromFile: loadFromFile,
		getChatLog: function () { return chatlog; }
	}
} (PodComms.Logging || {}));




// Messaging namespace
PodComms.Messaging = (function (parent) {

	// server messaging
	function send (event, obj) {
		var userSockets = PodComms.User.getSockets();

		for (var i = 0; i < userSockets.length; i++) {
			userSockets[i].emit(event, obj);
		}
	}

	function private (msg, to, from) {
		sendMessage(msg, {from:from, to:to});
	}

	function public (msg, from) {
		sendMessage(msg, {from:from});
	}

	function sendMessage (msg, parms) {
		parms = parms || {};

		// If not a server message
		if (parms.from)
			msg = parseMessage( msg );

		var obj = {
			'username': (parms.from && parms.from.name) ? parms.from.name : 'server',
			'colour': (parms.from && parms.from.colour) ? parms.from.colour : '#e20000',
			'message': msg,
			'datestamp': Date.now()
		};

		if (parms.to) {

			//private
			var userSockets = PodComms.User.getSockets();
			userSockets[parms.to.socketID].emit('updateChat', obj);

		} else {

			//public
			send('updateChat', obj);
			PodComms.Logging.logMessage (obj);

		}
	}

	function parseMessage (msg) {
		var linkRegex = /(\b(https?|ftp|file):\/\/[\-A-Z0-9+&@#\/%?=~_|!:,.;]*[\-A-Z0-9+&@#\/%=~_|])/ig;
		var links = msg.match(linkRegex);
		if (links) {
			for (var i=0; i<links.length; i++) {
				var l = links[i];

				if ( l.match(/(.gif|.jpg|.png)$/) ) {
					var embed = '<img src="' + l + '"/>';
					var rxstr = l.replace(/\//g, '\\/');
					var rx = RegExp(rxstr, 'i');
					msg = msg.replace(rx, embed);
				} else {
					var embed = '<a href="' + l + '" target="_blank">' + l + '</a>';
					var rxstr = l.replace(/\//g, '\\/').replace(/\?/g, '\\?');
					var rx = RegExp(rxstr, 'i');
					msg = msg.replace(rx, embed);
				}
			}
		}

		var imgRegex = /(data:image\/.*?):data/ig;
		msg = msg.replace(imgRegex, "<img src='$1'>");

		var nlRegex = /(\r\n|\n|\r)/gm
		msg = msg.replace(nlRegex, "<br />");

		return msg;
	}

	return {
		send: send,
		sendMessage: sendMessage,
		private: private,
		public: public
	}

} (PodComms.Messaging || {}));

// Socket events
io.of('/chat').on('connection', function(socket) {

	// disconnect
	socket.on('disconnect', function() {
		if (socket.username) {
			PodComms.User.remove (socket.username);
		}
	});

	process.on('exit', function() {
		PodComms.Messaging.public('SERVER IS SHUTING DOWN!!11');
		console.log('About to exit.');
	});

	// events
	socket.on('sendSignIn', function(d) {
		var user = PodComms.User.add(d, socket);
	});

	socket.on('testConnection', function(d) {
		if ( !PodComms.User.find(d.name) ) {
			PodComms.User.add(d.name, socket, d);
		}
	});

	socket.on('sendChat', function(d) {
		var user = PodComms.User.find(socket.username);

		if (!user) return;

		//strip html
		var msg = d.replace(/(<([^>]+)>)/ig,"");

		// Check commands
		msg = PodComms.Command.applyCommands(msg, user);

		// send chat
		if (msg.length > 0) {
			PodComms.Messaging.public(msg, user);
		}
	});
});

exports.Command = PodComms.Command;
exports.User = PodComms.User;
exports.Logging = PodComms.Logging;
exports.Messaging = PodComms.Messaging;

require('./plugins');