

var PodComms = require('PodComms');
var Voter = require('Voter');
var _ = require('underscore');
var fs = require('fs');

Array.splat = function (obj) {
	return _.isArray(obj) ? obj : [obj];
}

var lunchFile = 'lunch.json';
PodComms.Command.register('lunch', {
	description: 'Start the lunch voting',
	callback: function(user, msg, match) {

		// Read file
		fs.readFile(lunchFile, function (err, data) {

			if (err) {
				PodComms.Message.private('Lunch file read fail:'+err, user);
				PodComms.Logger.error( err );
				return;
			}

			if (data && data.length) {
				var places = JSON.parse( data );

				if (places && places.length > 0) {
					var userList = PodComms.User.getUsers();
					Voter.start('lunch', places, userList, voteCompleteCallback);
					return;
				}
			}
			
			PodComms.Message.private("Couldn't find any lunch places in the lunch file, sorry....", user);
		});
	}
});

function voteCompleteCallback (winner, scores) {
	PodComms.Message.public("<b>Location: </b>" + winner.name + '<br/><div class="map">'+winner.name+'</div>')

	// save scores, merge data from scores and from file, in case not all results are returned from scores
	fs.readFile(lunchFile, function (err, data) {

		if (err) {
			PodComms.Message.private('Lunch file read fail:'+err, user);
			PodComms.Logger.error( err );
			return;
		}

		if (data && data.length) {
			var places = JSON.parse( data );

			while (scores.length) {
				var place = scores.pop();

				var placeUpdated = {
					name: place.name,
					mapLink: place.item.mapLink,
					score: place.score,
					vetoCount: (place.veto ? 1 : 0)
				}

				for (var i = 0; i < places.length; i++) {
					if (places[i].name == placeUpdated.name) {
						placeUpdated.score += (places[i].score || 0);
						placeUpdated.vetoCount += (places[i].vetoCount || 0);
						places[i] = placeUpdated;
						break;
					}
				}
			}

			fs.writeFileSync(lunchFile, JSON.stringify(places, null, 4));
			PodComms.Message.public('The lunch file has been updated');
		}
	});
}

PodComms.Command.register('lunchadd', {
	description: 'Add a place to the lunch file, use street name for chains',
	example: '/lunchadd Nandos Russell Street',
	callback: function(user, msg, match){
		var places = getDataFromFile(lunchFile);

		if (match.length > 0) {

			var name = match[1];

			places.push({
				name: name,
				added: Date.now()
			});

			putDataToFile (lunchFile, places);
			PodComms.Message.public(name + ' has been added to the lunch list<br/><div class="map">'+ name +'</div>');
		}
	}
});

PodComms.Command.register('lunchdel', {
	description: 'Delete a place from the lunch file by name',
	example: '/lunchdel Yum Cha',
	callback: function(user, msg, match){
		var places = getDataFromFile(lunchFile);

		if (match.length > 0) {

			var name = match[1];

			for (var i = 0; i < places.length; i++) {
				if (name == places[i].name) {
					places.splice(i,1);
					putDataToFile (lunchFile, places);
					PodComms.Message.public(name + ' has been removed from the lunch. '+user.name+', you hater...');
					return false;
				}
			}

			PodComms.Message.private(name + ' not found', user);
			return false;
		}
		PodComms.Message.private('Just give me a name...', user);
	}
});

PodComms.Command.register('lunchlist', {
	callback: function(user, msg, match){
		var places = getDataFromFile(lunchFile);

		var choices = [];

		while (places.length) {
			var p = places.pop();
			choices.push( p.name + ' (' + (p.score || 0) + ')');
		}

		PodComms.Message.private('Here are the choices:<br /><ol><li>' + choices.join('</li><li>') + '</li></ol>', user);
	}
});